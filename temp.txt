import React, { useMemo, useState } from 'react';
import { Card as CardType, Invoice, InvoiceStatus, Transaction, TransactionType, PaymentMethod } from '../../types';
import UICard from '../ui/Card';
import Button from '../ui/Button';
import Select from '../ui/Select';
import Input from '../ui/Input';
import { formatCurrency, formatDate } from '../../utils/formatters';
import CardCarousel from '../dashboard/CardCarousel';

type EnhancedCard = CardType & { availableLimit: number; currentInvoiceAmount: number; dueDate: string; invoiceStatus: InvoiceStatus };

interface CardsDashboardPageProps {
  cards: EnhancedCard[];
  invoices: Invoice[];
  transactions: Transaction[];
  onUpdateInvoiceStatus: (invoiceId: string, status: InvoiceStatus) => void;
  onPartialInvoicePayment: (invoiceId: string, amount: number) => void;
}

const CardsDashboardPage: React.FC<CardsDashboardPageProps> = ({ cards, invoices, transactions, onUpdateInvoiceStatus, onPartialInvoicePayment }) => {
  const [dateRange, setDateRange] = useState<'this-month' | 'last-30-days' | 'all-time' | 'custom'>('this-month');
  const [customStart, setCustomStart] = useState<string>('');
  const [customEnd, setCustomEnd] = useState<string>('');
  const [selectedCardId, setSelectedCardId] = useState<string>('all');
  const [partialInputs, setPartialInputs] = useState<Record<string, string>>({});

  const COLORS = ['#6366f1', '#8b5cf6', '#f97316', '#10b981', '#ef4444', '#14b8a6'];

  const getRanges = () => {
    const now = new Date();
    let start = new Date(now.getFullYear(), now.getMonth(), 1);
    let end = new Date(now.getFullYear(), now.getMonth() + 1, 0);
    if (dateRange === 'last-30-days') {
      end = new Date();
      start = new Date();
      start.setDate(end.getDate() - 30);
    } else if (dateRange === 'all-time') {
      start = new Date(2000, 0, 1);
      end = new Date(2100, 0, 1);
    } else if (dateRange === 'custom') {
      start = customStart ? new Date(customStart) : new Date(2000, 0, 1);
      end = customEnd ? new Date(customEnd) : new Date(2100, 0, 1);
    }
    const spanDays = Math.max(1, Math.ceil((end.getTime() - start.getTime()) / (1000*60*60*24)));
    const prevEnd = new Date(start);
    const prevStart = new Date(start);
    prevStart.setDate(prevStart.getDate() - spanDays);
    return { start, end, prevStart, prevEnd };
  };

  const { filteredTransactions, totalExpenses, prevTotalExpenses } = useMemo(() => {
    const { start, end, prevStart, prevEnd } = getRanges();
    const filterTx = (s: Date, e: Date) => transactions.filter(tx => {
      const d = new Date(tx.date);
      const byDate = d >= s && d <= e;
      const byType = tx.type === TransactionType.Expense;
      const byMethod = tx.paymentMethod === PaymentMethod.Credit || tx.paymentMethod === PaymentMethod.Debit;
      const byCard = selectedCardId === 'all' ? true : tx.sourceId === selectedCardId;
      return byDate && byType && byMethod && byCard;
    });

    const cur = filterTx(start, end);
    const prev = filterTx(prevStart, prevEnd);
    const curTotal = cur.reduce((s, t) => s + t.amount, 0);
    const prevTotal = prev.reduce((s, t) => s + t.amount, 0);
    return { filteredTransactions: cur, totalExpenses: curTotal, prevTotalExpenses: prevTotal };
  }, [transactions, dateRange, customStart, customEnd, selectedCardId]);

  const totals = useMemo(() => {
    const selectedCards = selectedCardId === 'all' ? cards : cards.filter(c => c.id === selectedCardId);
    const totalLimit = selectedCards.reduce((sum, c) => sum + c.limit, 0);
    const totalAvailable = selectedCards.reduce((sum, c) => sum + c.availableLimit, 0);
    return { totalLimit, totalAvailable };
  }, [cards, selectedCardId]);

  // Removido gráfico de "Gasto por Cartão"; cálculo agregado por cartão não é mais necessário aqui.

  const categoryData = useMemo(() => {
    const map: Record<string, number> = {};
    filteredTransactions.forEach(t => { map[t.category] = (map[t.category] || 0) + t.amount; });
    return Object.entries(map).map(([name, value]) => ({ name, value })).sort((a,b)=>b.value - a.value);
  }, [filteredTransactions]);

  const trend = prevTotalExpenses > 0 ? ((totalExpenses - prevTotalExpenses) / prevTotalExpenses) * 100 : 0;

  const invoicesInRange = useMemo(() => {
    const { start, end } = getRanges();
    return invoices.filter(inv => {
      const due = new Date(inv.dueDate);
      const byDate = due >= start && due <= end;
      const byCard = selectedCardId === 'all' ? true : inv.cardId === selectedCardId;
      return byDate && byCard;
    });
  }, [invoices, dateRange, customStart, customEnd, selectedCardId]);

  const handlePartialChange = (id: string, value: string) => setPartialInputs(prev => ({ ...prev, [id]: value }));
  const applyPartial = (id: string) => {
    const raw = partialInputs[id];
    const amount = parseFloat((raw || '').replace(',', '.'));
    if (Number.isFinite(amount) && amount > 0) {
      onPartialInvoicePayment(id, amount);
      setPartialInputs(prev => ({ ...prev, [id]: '' }));
    }
  };

  return (
    <div className="p-4 sm:p-8 space-y-8 min-h-screen">
      <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
        <div>
          <h1 className="text-3xl sm:text-4xl font-heading text-neutral-800 dark:text-neutral-100">Sua Visão Financeira</h1>
        </div>
      </header>

      {/* Filtros acima dos cards de valor */}
      <UICard title="Filtros">
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
          <Select label="Período" name="periodo" value={dateRange} onChange={e=>setDateRange(e.target.value as any)}>
            <option value="this-month">Este Mês</option>
            <option value="last-30-days">Últimos 30 dias</option>
            <option value="all-time">Todo o período</option>
            <option value="custom">Personalizado</option>
          </Select>
          {dateRange === 'custom' && (
            <>
              <Input label="Início" name="inicio" type="date" value={customStart} onChange={e=>setCustomStart(e.target.value)} />
              <Input label="Fim" name="fim" type="date" value={customEnd} onChange={e=>setCustomEnd(e.target.value)} />
            </>
          )}
          <Select label="Cartão" name="cartao" value={selectedCardId} onChange={e=>setSelectedCardId(e.target.value)}>
            <option value="all">Todos os Cartões</option>
            {cards.map(c => <option key={c.id} value={c.id}>{c.nickname} (••{c.last4})</option>)}
          </Select>
        </div>
      </UICard>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <UICard>
          <div className="text-neutral-500 dark:text-neutral-400 text-sm">Despesa Mensal Total</div>
          <div className="mt-2 text-3xl font-heading font-semibold">{formatCurrency(totalExpenses)}</div>
          <div className={`text-sm font-bold mt-2 ${trend >= 0 ? 'text-emerald-500' : 'text-red-500'}`}>{`${trend >= 0 ? '+' : ''}${trend.toFixed(1)}%`}</div>
        </UICard>
        <UICard>
          <div className="text-neutral-500 dark:text-neutral-400 text-sm">Crédito Disponível Total</div>
          <div className="mt-2 text-3xl font-heading font-semibold">{formatCurrency(totals.totalAvailable)}</div>
          <div className="text-sm font-bold mt-2 text-neutral-400">de {formatCurrency(totals.totalLimit)}</div>
        </UICard>
        <UICard>
          <div className="text-neutral-500 dark:text-neutral-400 text-sm">Limite Total dos Cartões</div>
          <div className="mt-2 text-3xl font-heading font-semibold">{formatCurrency(totals.totalLimit)}</div>
        </UICard>
      </div>

      <div className="grid grid-cols-1 gap-6 items-stretch">
        <UICard title="Meus Cartões">
          <div className="px-2">
            <CardCarousel
              cards={(selectedCardId === 'all' ? cards : cards.filter(c => c.id === selectedCardId)) as any}
              onCardClick={(/* card */) => { /* no-op por ora */ }}
            />
          </div>
          {/* Mantido apenas o carrossel conforme solicitado */}
        </UICard>
      </div>

      <UICard title="Gastos por Categoria">
        <div className="space-y-3">
          {categoryData.map((c,i)=>{
            const pct = totalExpenses > 0 ? (c.value / totalExpenses) * 100 : 0;
            return (
              <div key={c.name} className="grid grid-cols-12 items-center gap-3">
                <div className="col-span-3 sm:col-span-2 text-sm text-neutral-600 dark:text-neutral-300">{c.name}</div>
                <div className="col-span-7 sm:col-span-8">
                  <div className="w-full h-2 bg-neutral-200 rounded-full overflow-hidden">
                    <div className="h-2 rounded-full" style={{ width: `${pct}%`, backgroundColor: COLORS[i % COLORS.length] }} />
                  </div>
                </div>
                <div className="col-span-2 text-right text-sm font-semibold">{formatCurrency(c.value)}</div>
              </div>
            );
          })}
        </div>
      </UICard>

      <UICard>
        <div className="flex items-center justify-between mb-4">
          <h3 className="font-heading text-lg text-neutral-700 dark:text-neutral-200">Transações Recentes</h3>
          <div className="flex gap-3 w-full max-w-xl justify-end">
            <Select label="Filtrar por Cartão" name="filtroCartao" value={selectedCardId} onChange={e=>setSelectedCardId(e.target.value)}>
              <option value="all">Todos</option>
              {cards.map(c => <option key={c.id} value={c.id}>{c.nickname} (••{c.last4})</option>)}
            </Select>
            <div className="grid grid-cols-2 gap-2">
              <Input label="Início" name="txStart" type="date" value={customStart} onChange={e=>{setCustomStart(e.target.value); setDateRange('custom')}} />
              <Input label="Fim" name="txEnd" type="date" value={customEnd} onChange={e=>{setCustomEnd(e.target.value); setDateRange('custom')}} />
            </div>
          </div>
        </div>
        <div className="overflow-x-auto">
          <table className="min-w-full text-sm">
            <thead>
              <tr className="text-left text-neutral-500">
                <th className="py-2 pr-4">Comerciante</th>
                <th className="py-2 pr-4">Data</th>
                <th className="py-2 pr-4">Valor</th>
                <th className="py-2 pr-4">Status</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-neutral-200 dark:divide-neutral-700">
              {[...filteredTransactions].sort((a,b)=>new Date(b.date).getTime()-new Date(a.date).getTime()).slice(0,10).map(tx => {
                const status = tx.paymentMethod === PaymentMethod.Credit ? 'Pendente' : 'Pago';
                return (
                  <tr key={tx.id}>
                    <td className="py-3 pr-4">{tx.description}</td>
                    <td className="py-3 pr-4">{new Date(tx.date).toLocaleDateString('pt-BR')}</td>
                    <td className="py-3 pr-4 font-semibold">-{formatCurrency(tx.amount)}</td>
                    <td className="py-3 pr-4">
                      <span className={`px-2.5 py-1 text-xs font-bold rounded-full ${status==='Pago' ? 'bg-emerald-100 text-emerald-700' : 'bg-amber-100 text-amber-700'}`}>{status}</span>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      </UICard>

      {/* Faturas detalhadas com pagamento total/parcial */}
      <UICard title="Faturas Detalhadas">
        <div className="overflow-x-auto">
          <table className="min-w-full text-sm">
            <thead>
              <tr className="text-left text-neutral-500">
                <th className="py-2 pr-4">Cartão</th>
                <th className="py-2 pr-4">Mês</th>
                <th className="py-2 pr-4">Vencimento</th>
                <th className="py-2 pr-4">Valor</th>
                <th className="py-2 pr-4">Pago</th>
                <th className="py-2 pr-4">Status</th>
                <th className="py-2 pr-4">Ações</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-neutral-200 dark:divide-neutral-700">
              {invoicesInRange.map(inv => {
                const card = cards.find(c => c.id === inv.cardId);
                const paid = inv.paidAmount ?? (inv.status === InvoiceStatus.Paid ? inv.totalAmount : 0);
                const remaining = Math.max(0, inv.totalAmount - paid);
                return (
                  <tr key={inv.id}>
                    <td className="py-3 pr-4">{card?.nickname} <span className="text-neutral-400">(••{card?.last4})</span></td>
                    <td className="py-3 pr-4">{inv.month}/{inv.year}</td>
                    <td className="py-3 pr-4">{formatDate(inv.dueDate)}</td>
                    <td className="py-3 pr-4 font-semibold">{formatCurrency(inv.totalAmount)}</td>
                    <td className="py-3 pr-4">{formatCurrency(paid)}</td>
                    <td className="py-3 pr-4">{inv.status}</td>
                    <td className="py-3 pr-4">
                      <div className="flex items-center gap-2">
                        <Button size="sm" variant="secondary" onClick={() => onUpdateInvoiceStatus(inv.id, InvoiceStatus.Paid)} disabled={remaining <= 0}>Pagar Total</Button>
                        <Input label="" name={`partial-${inv.id}`} placeholder="Parcial" value={partialInputs[inv.id] || ''} onChange={e => handlePartialChange(inv.id, e.target.value)} className="w-28" />
                        <Button size="sm" variant="primary" onClick={() => applyPartial(inv.id)} disabled={!partialInputs[inv.id]}>Aplicar</Button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      </UICard>
    </div>
  );
};

export default CardsDashboardPage;
